use super::{operation::*, HighLevelILFunction};

#[derive(Clone, Debug, PartialEq)]
pub enum HighLevelILLiftedInstruction {
    Adc(LiftedBinaryOpCarry),
    Sbb(LiftedBinaryOpCarry),
    Rlc(LiftedBinaryOpCarry),
    Rrc(LiftedBinaryOpCarry),
    Add(LiftedBinaryOp),
    Sub(LiftedBinaryOp),
    And(LiftedBinaryOp),
    Or(LiftedBinaryOp),
    Xor(LiftedBinaryOp),
    Lsl(LiftedBinaryOp),
    Lsr(LiftedBinaryOp),
    Asr(LiftedBinaryOp),
    Rol(LiftedBinaryOp),
    Ror(LiftedBinaryOp),
    Mul(LiftedBinaryOp),
    MuluDp(LiftedBinaryOp),
    MulsDp(LiftedBinaryOp),
    Divu(LiftedBinaryOp),
    DivuDp(LiftedBinaryOp),
    Divs(LiftedBinaryOp),
    DivsDp(LiftedBinaryOp),
    Modu(LiftedBinaryOp),
    ModuDp(LiftedBinaryOp),
    Mods(LiftedBinaryOp),
    ModsDp(LiftedBinaryOp),
    CmpE(LiftedBinaryOp),
    CmpNe(LiftedBinaryOp),
    CmpSlt(LiftedBinaryOp),
    CmpUlt(LiftedBinaryOp),
    CmpSle(LiftedBinaryOp),
    CmpUle(LiftedBinaryOp),
    CmpSge(LiftedBinaryOp),
    CmpUge(LiftedBinaryOp),
    CmpSgt(LiftedBinaryOp),
    CmpUgt(LiftedBinaryOp),
    TestBit(LiftedBinaryOp),
    AddOverflow(LiftedBinaryOp),
    Fadd(LiftedBinaryOp),
    Fsub(LiftedBinaryOp),
    Fmul(LiftedBinaryOp),
    Fdiv(LiftedBinaryOp),
    FcmpE(LiftedBinaryOp),
    FcmpNe(LiftedBinaryOp),
    FcmpLt(LiftedBinaryOp),
    FcmpLe(LiftedBinaryOp),
    FcmpGe(LiftedBinaryOp),
    FcmpGt(LiftedBinaryOp),
    FcmpO(LiftedBinaryOp),
    FcmpUo(LiftedBinaryOp),
    ArrayIndex(LiftedArrayIndex),
    ArrayIndexSsa(LiftedArrayIndexSsa),
    Assign(LiftedAssign),
    AssignMemSsa(LiftedAssignMemSsa),
    AssignUnpack(LiftedAssignUnpack),
    AssignUnpackMemSsa(LiftedAssignUnpackMemSsa),
    Block(LiftedBlock),
    Call(LiftedCall),
    Tailcall(LiftedCall),
    CallSsa(LiftedCallSsa),
    Case(LiftedCase),
    Const(Const),
    ConstPtr(Const),
    Import(Const),
    ConstData(LiftedConstantData),
    Deref(LiftedUnaryOp),
    AddressOf(LiftedUnaryOp),
    Neg(LiftedUnaryOp),
    Not(LiftedUnaryOp),
    Sx(LiftedUnaryOp),
    Zx(LiftedUnaryOp),
    LowPart(LiftedUnaryOp),
    BoolToInt(LiftedUnaryOp),
    UnimplMem(LiftedUnaryOp),
    Fsqrt(LiftedUnaryOp),
    Fneg(LiftedUnaryOp),
    Fabs(LiftedUnaryOp),
    FloatToInt(LiftedUnaryOp),
    IntToFloat(LiftedUnaryOp),
    FloatConv(LiftedUnaryOp),
    RoundToInt(LiftedUnaryOp),
    Floor(LiftedUnaryOp),
    Ceil(LiftedUnaryOp),
    Ftrunc(LiftedUnaryOp),
    DerefFieldSsa(LiftedDerefFieldSsa),
    DerefSsa(LiftedDerefSsa),
    ExternPtr(ExternPtr),
    FloatConst(FloatConst),
    For(LiftedForLoop),
    ForSsa(LiftedForLoopSsa),
    Goto(Label),
    Label(Label),
    If(LiftedIf),
    Intrinsic(LiftedIntrinsic),
    IntrinsicSsa(LiftedIntrinsicSsa),
    Jump(Jump),
    MemPhi(LiftedMemPhi),
    Nop(NoArgs),
    Break(NoArgs),
    Continue(NoArgs),
    Noret(NoArgs),
    Unreachable(NoArgs),
    Bp(NoArgs),
    Undef(NoArgs),
    Unimpl(NoArgs),
    Ret(LiftedRet),
    Split(LiftedSplit),
    StructField(LiftedStructField),
    DerefField(LiftedStructField),
    Switch(LiftedSwitch),
    Syscall(LiftedSyscall),
    SyscallSsa(LiftedSyscallSsa),
    Trap(Trap),
    VarDeclare(Var),
    Var(Var),
    VarInit(LiftedVarInit),
    VarInitSsa(LiftedVarInitSsa),
    VarPhi(LiftedVarPhi),
    VarSsa(VarSsa),
    While(LiftedWhile),
    DoWhile(LiftedWhile),
    WhileSsa(LiftedWhileSsa),
    DoWhileSsa(LiftedWhileSsa),
}

impl HighLevelILLiftedInstruction {
    pub fn address(&self) -> u64 {
        use HighLevelILLiftedInstruction::*;
        match self {
            Adc(op) => op.address,
            Sbb(op) => op.address,
            Rlc(op) => op.address,
            Rrc(op) => op.address,
            Add(op) => op.address,
            Sub(op) => op.address,
            And(op) => op.address,
            Or(op) => op.address,
            Xor(op) => op.address,
            Lsl(op) => op.address,
            Lsr(op) => op.address,
            Asr(op) => op.address,
            Rol(op) => op.address,
            Ror(op) => op.address,
            Mul(op) => op.address,
            MuluDp(op) => op.address,
            MulsDp(op) => op.address,
            Divu(op) => op.address,
            DivuDp(op) => op.address,
            Divs(op) => op.address,
            DivsDp(op) => op.address,
            Modu(op) => op.address,
            ModuDp(op) => op.address,
            Mods(op) => op.address,
            ModsDp(op) => op.address,
            CmpE(op) => op.address,
            CmpNe(op) => op.address,
            CmpSlt(op) => op.address,
            CmpUlt(op) => op.address,
            CmpSle(op) => op.address,
            CmpUle(op) => op.address,
            CmpSge(op) => op.address,
            CmpUge(op) => op.address,
            CmpSgt(op) => op.address,
            CmpUgt(op) => op.address,
            TestBit(op) => op.address,
            AddOverflow(op) => op.address,
            Fadd(op) => op.address,
            Fsub(op) => op.address,
            Fmul(op) => op.address,
            Fdiv(op) => op.address,
            FcmpE(op) => op.address,
            FcmpNe(op) => op.address,
            FcmpLt(op) => op.address,
            FcmpLe(op) => op.address,
            FcmpGe(op) => op.address,
            FcmpGt(op) => op.address,
            FcmpO(op) => op.address,
            FcmpUo(op) => op.address,
            ArrayIndex(op) => op.address,
            ArrayIndexSsa(op) => op.address,
            Assign(op) => op.address,
            AssignMemSsa(op) => op.address,
            AssignUnpack(op) => op.address,
            AssignUnpackMemSsa(op) => op.address,
            Block(op) => op.address,
            Call(op) => op.address,
            Tailcall(op) => op.address,
            CallSsa(op) => op.address,
            Case(op) => op.address,
            Const(op) => op.address,
            ConstPtr(op) => op.address,
            Import(op) => op.address,
            ConstData(op) => op.address,
            Deref(op) => op.address,
            AddressOf(op) => op.address,
            Neg(op) => op.address,
            Not(op) => op.address,
            Sx(op) => op.address,
            Zx(op) => op.address,
            LowPart(op) => op.address,
            BoolToInt(op) => op.address,
            UnimplMem(op) => op.address,
            Fsqrt(op) => op.address,
            Fneg(op) => op.address,
            Fabs(op) => op.address,
            FloatToInt(op) => op.address,
            IntToFloat(op) => op.address,
            FloatConv(op) => op.address,
            RoundToInt(op) => op.address,
            Floor(op) => op.address,
            Ceil(op) => op.address,
            Ftrunc(op) => op.address,
            DerefFieldSsa(op) => op.address,
            DerefSsa(op) => op.address,
            ExternPtr(op) => op.address,
            FloatConst(op) => op.address,
            For(op) => op.address,
            ForSsa(op) => op.address,
            Goto(op) => op.address,
            Label(op) => op.address,
            If(op) => op.address,
            Intrinsic(op) => op.address,
            IntrinsicSsa(op) => op.address,
            Jump(op) => op.address,
            MemPhi(op) => op.address,
            Nop(op) => op.address,
            Break(op) => op.address,
            Continue(op) => op.address,
            Noret(op) => op.address,
            Unreachable(op) => op.address,
            Bp(op) => op.address,
            Undef(op) => op.address,
            Unimpl(op) => op.address,
            Ret(op) => op.address,
            Split(op) => op.address,
            StructField(op) => op.address,
            DerefField(op) => op.address,
            Switch(op) => op.address,
            Syscall(op) => op.address,
            SyscallSsa(op) => op.address,
            Trap(op) => op.address,
            VarDeclare(op) => op.address,
            Var(op) => op.address,
            VarInit(op) => op.address,
            VarInitSsa(op) => op.address,
            VarPhi(op) => op.address,
            VarSsa(op) => op.address,
            While(op) => op.address,
            DoWhile(op) => op.address,
            WhileSsa(op) => op.address,
            DoWhileSsa(op) => op.address,
        }
    }

    pub fn function(&self) -> &HighLevelILFunction {
        use HighLevelILLiftedInstruction::*;
        match self {
            Adc(op) => &op.function,
            Sbb(op) => &op.function,
            Rlc(op) => &op.function,
            Rrc(op) => &op.function,
            Add(op) => &op.function,
            Sub(op) => &op.function,
            And(op) => &op.function,
            Or(op) => &op.function,
            Xor(op) => &op.function,
            Lsl(op) => &op.function,
            Lsr(op) => &op.function,
            Asr(op) => &op.function,
            Rol(op) => &op.function,
            Ror(op) => &op.function,
            Mul(op) => &op.function,
            MuluDp(op) => &op.function,
            MulsDp(op) => &op.function,
            Divu(op) => &op.function,
            DivuDp(op) => &op.function,
            Divs(op) => &op.function,
            DivsDp(op) => &op.function,
            Modu(op) => &op.function,
            ModuDp(op) => &op.function,
            Mods(op) => &op.function,
            ModsDp(op) => &op.function,
            CmpE(op) => &op.function,
            CmpNe(op) => &op.function,
            CmpSlt(op) => &op.function,
            CmpUlt(op) => &op.function,
            CmpSle(op) => &op.function,
            CmpUle(op) => &op.function,
            CmpSge(op) => &op.function,
            CmpUge(op) => &op.function,
            CmpSgt(op) => &op.function,
            CmpUgt(op) => &op.function,
            TestBit(op) => &op.function,
            AddOverflow(op) => &op.function,
            Fadd(op) => &op.function,
            Fsub(op) => &op.function,
            Fmul(op) => &op.function,
            Fdiv(op) => &op.function,
            FcmpE(op) => &op.function,
            FcmpNe(op) => &op.function,
            FcmpLt(op) => &op.function,
            FcmpLe(op) => &op.function,
            FcmpGe(op) => &op.function,
            FcmpGt(op) => &op.function,
            FcmpO(op) => &op.function,
            FcmpUo(op) => &op.function,
            ArrayIndex(op) => &op.function,
            ArrayIndexSsa(op) => &op.function,
            Assign(op) => &op.function,
            AssignMemSsa(op) => &op.function,
            AssignUnpack(op) => &op.function,
            AssignUnpackMemSsa(op) => &op.function,
            Block(op) => &op.function,
            Call(op) => &op.function,
            Tailcall(op) => &op.function,
            CallSsa(op) => &op.function,
            Case(op) => &op.function,
            Const(op) => &op.function,
            ConstPtr(op) => &op.function,
            Import(op) => &op.function,
            ConstData(op) => &op.function,
            Deref(op) => &op.function,
            AddressOf(op) => &op.function,
            Neg(op) => &op.function,
            Not(op) => &op.function,
            Sx(op) => &op.function,
            Zx(op) => &op.function,
            LowPart(op) => &op.function,
            BoolToInt(op) => &op.function,
            UnimplMem(op) => &op.function,
            Fsqrt(op) => &op.function,
            Fneg(op) => &op.function,
            Fabs(op) => &op.function,
            FloatToInt(op) => &op.function,
            IntToFloat(op) => &op.function,
            FloatConv(op) => &op.function,
            RoundToInt(op) => &op.function,
            Floor(op) => &op.function,
            Ceil(op) => &op.function,
            Ftrunc(op) => &op.function,
            DerefFieldSsa(op) => &op.function,
            DerefSsa(op) => &op.function,
            ExternPtr(op) => &op.function,
            FloatConst(op) => &op.function,
            For(op) => &op.function,
            ForSsa(op) => &op.function,
            Goto(op) => &op.function,
            Label(op) => &op.function,
            If(op) => &op.function,
            Intrinsic(op) => &op.function,
            IntrinsicSsa(op) => &op.function,
            Jump(op) => &op.function,
            MemPhi(op) => &op.function,
            Nop(op) => &op.function,
            Break(op) => &op.function,
            Continue(op) => &op.function,
            Noret(op) => &op.function,
            Unreachable(op) => &op.function,
            Bp(op) => &op.function,
            Undef(op) => &op.function,
            Unimpl(op) => &op.function,
            Ret(op) => &op.function,
            Split(op) => &op.function,
            StructField(op) => &op.function,
            DerefField(op) => &op.function,
            Switch(op) => &op.function,
            Syscall(op) => &op.function,
            SyscallSsa(op) => &op.function,
            Trap(op) => &op.function,
            VarDeclare(op) => &op.function,
            Var(op) => &op.function,
            VarInit(op) => &op.function,
            VarInitSsa(op) => &op.function,
            VarPhi(op) => &op.function,
            VarSsa(op) => &op.function,
            While(op) => &op.function,
            DoWhile(op) => &op.function,
            WhileSsa(op) => &op.function,
            DoWhileSsa(op) => &op.function,
        }
    }
}
